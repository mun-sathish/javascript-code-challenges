# ðŸ”§ DOM Manipulation Concepts & Patterns

> **Master DOM manipulation for frontend interviews**
>
> Essential concepts with practical examples

---

## 1. Selecting Elements

### Methods Overview

```javascript
// Single element selectors
const element1 = document.getElementById('myId');
const element2 = document.querySelector('.myClass');
const element3 = document.querySelector('#myId');

// Multiple elements selectors
const elements1 = document.getElementsByClassName('myClass'); // HTMLCollection
const elements2 = document.getElementsByTagName('div'); // HTMLCollection
const elements3 = document.querySelectorAll('.myClass'); // NodeList

// Difference: NodeList vs HTMLCollection
// NodeList: Static (querySelectorAll) or Live (childNodes)
// HTMLCollection: Always live, updates automatically
```

### Practical Example: Dynamic Element Selection

```html
<div id="container">
  <button class="btn">Button 1</button>
  <button class="btn">Button 2</button>
  <button class="btn">Button 3</button>
</div>
```

```javascript
// Get all buttons
const buttons = document.querySelectorAll('.btn');

// Convert NodeList to Array for array methods
const buttonArray = Array.from(buttons);
// or
const buttonArray2 = [...buttons];

// Iterate and add event listeners
buttons.forEach((btn, index) => {
  btn.addEventListener('click', () => {
    console.log(`Button ${index + 1} clicked`);
  });
});
```

---

## 2. Creating & Inserting Elements

### Creating Elements

```javascript
// Method 1: createElement
const div = document.createElement('div');
div.className = 'card';
div.id = 'myCard';
div.textContent = 'Hello World';

// Method 2: innerHTML (use cautiously - XSS risk)
const container = document.getElementById('container');
container.innerHTML = '<div class="card">Hello World</div>';

// Method 3: insertAdjacentHTML (safer, more flexible)
container.insertAdjacentHTML('beforeend', '<div class="card">New Card</div>');

// Method 4: Template literals with createElement
function createCard(title, content) {
  const card = document.createElement('div');
  card.className = 'card';
  card.innerHTML = `
    <h3>${title}</h3>
    <p>${content}</p>
  `;
  return card;
}
```

### Insertion Methods

```javascript
const parent = document.getElementById('parent');
const child = document.createElement('div');

// Insert methods
parent.appendChild(child);           // Add as last child
parent.prepend(child);               // Add as first child
parent.append(child1, child2);       // Add multiple as last children
parent.insertBefore(child, refNode); // Insert before reference node

// Modern methods
parent.before(child);  // Insert before parent
parent.after(child);   // Insert after parent
parent.replaceWith(newElement); // Replace parent

// insertAdjacentElement positions
element.insertAdjacentElement('beforebegin', newEl); // Before element
element.insertAdjacentElement('afterbegin', newEl);  // First child
element.insertAdjacentElement('beforeend', newEl);   // Last child
element.insertAdjacentElement('afterend', newEl);    // After element
```

### Practical Example: Dynamic List

```html
<div id="todoContainer">
  <input type="text" id="todoInput" placeholder="Enter todo">
  <button id="addBtn">Add Todo</button>
  <ul id="todoList"></ul>
</div>
```

```javascript
const input = document.getElementById('todoInput');
const addBtn = document.getElementById('addBtn');
const todoList = document.getElementById('todoList');

function createTodoItem(text) {
  const li = document.createElement('li');
  li.className = 'todo-item';
  
  const span = document.createElement('span');
  span.textContent = text;
  
  const deleteBtn = document.createElement('button');
  deleteBtn.textContent = 'Delete';
  deleteBtn.className = 'delete-btn';
  deleteBtn.onclick = () => li.remove();
  
  li.appendChild(span);
  li.appendChild(deleteBtn);
  
  return li;
}

addBtn.addEventListener('click', () => {
  const text = input.value.trim();
  if (text) {
    const todoItem = createTodoItem(text);
    todoList.appendChild(todoItem);
    input.value = '';
  }
});
```

---

## 3. Modifying Elements

### Attributes

```javascript
const element = document.querySelector('.myElement');

// Get/Set attributes
element.getAttribute('data-id');
element.setAttribute('data-id', '123');
element.removeAttribute('data-id');
element.hasAttribute('data-id');

// Direct property access (preferred for standard attributes)
element.id = 'newId';
element.className = 'newClass';
element.href = 'https://example.com';

// Data attributes
element.dataset.userId = '123';  // Sets data-user-id="123"
console.log(element.dataset.userId); // Gets data-user-id value
```

### Classes

```javascript
const element = document.querySelector('.myElement');

// classList methods (modern, preferred)
element.classList.add('active');
element.classList.remove('inactive');
element.classList.toggle('visible');
element.classList.contains('active'); // Returns boolean
element.classList.replace('old', 'new');

// Multiple classes
element.classList.add('class1', 'class2', 'class3');
element.classList.remove('class1', 'class2');

// Old way (avoid)
element.className = 'newClass'; // Replaces all classes
element.className += ' additionalClass'; // Appends
```

### Styles

```javascript
const element = document.querySelector('.myElement');

// Inline styles
element.style.color = 'red';
element.style.backgroundColor = 'blue';
element.style.fontSize = '16px';

// Multiple styles
Object.assign(element.style, {
  color: 'red',
  backgroundColor: 'blue',
  fontSize: '16px',
  padding: '10px'
});

// CSS Text (sets all at once)
element.style.cssText = 'color: red; background: blue; font-size: 16px;';

// Get computed styles
const styles = window.getComputedStyle(element);
console.log(styles.color);
console.log(styles.fontSize);
```

### Content

```javascript
const element = document.querySelector('.myElement');

// Text content (safe, no HTML parsing)
element.textContent = 'Hello World';

// Inner HTML (parses HTML, XSS risk)
element.innerHTML = '<strong>Bold Text</strong>';

// Inner Text (considers CSS, slower)
element.innerText = 'Visible Text';

// Outer HTML (replaces element itself)
element.outerHTML = '<div>New Element</div>';
```

---

## 4. Event Handling

### Adding Event Listeners

```javascript
const button = document.querySelector('button');

// Method 1: addEventListener (preferred)
button.addEventListener('click', function(event) {
  console.log('Clicked!', event);
});

// Method 2: Arrow function
button.addEventListener('click', (e) => {
  console.log('Clicked!', e.target);
});

// Method 3: Named function (for removal)
function handleClick(e) {
  console.log('Clicked!');
}
button.addEventListener('click', handleClick);
button.removeEventListener('click', handleClick);

// Method 4: Once option (auto-removes after first trigger)
button.addEventListener('click', handler, { once: true });

// Method 5: Capture phase
button.addEventListener('click', handler, { capture: true });
```

### Event Delegation

```javascript
// Instead of adding listeners to each item
const parent = document.getElementById('parent');

parent.addEventListener('click', (e) => {
  // Check if clicked element matches selector
  if (e.target.matches('.child-button')) {
    console.log('Child button clicked:', e.target);
  }
  
  // Or use closest for nested elements
  const button = e.target.closest('.child-button');
  if (button) {
    console.log('Button clicked:', button);
  }
});
```

### Practical Example: Dynamic Todo with Delegation

```html
<div id="app">
  <input type="text" id="input">
  <button id="add">Add</button>
  <ul id="list"></ul>
</div>
```

```javascript
const app = document.getElementById('app');
const input = document.getElementById('input');
const list = document.getElementById('list');

// Single event listener for all interactions
app.addEventListener('click', (e) => {
  // Add todo
  if (e.target.id === 'add') {
    const text = input.value.trim();
    if (text) {
      const li = document.createElement('li');
      li.innerHTML = `
        <span>${text}</span>
        <button class="delete">Delete</button>
        <button class="toggle">Toggle</button>
      `;
      list.appendChild(li);
      input.value = '';
    }
  }
  
  // Delete todo
  if (e.target.classList.contains('delete')) {
    e.target.closest('li').remove();
  }
  
  // Toggle todo
  if (e.target.classList.contains('toggle')) {
    e.target.closest('li').classList.toggle('completed');
  }
});
```

### Common Events

```javascript
// Mouse events
element.addEventListener('click', handler);
element.addEventListener('dblclick', handler);
element.addEventListener('mouseenter', handler);
element.addEventListener('mouseleave', handler);
element.addEventListener('mousemove', handler);

// Keyboard events
element.addEventListener('keydown', handler);
element.addEventListener('keyup', handler);
element.addEventListener('keypress', handler); // Deprecated

// Form events
form.addEventListener('submit', handler);
input.addEventListener('input', handler);  // Every change
input.addEventListener('change', handler); // After blur
input.addEventListener('focus', handler);
input.addEventListener('blur', handler);

// Window events
window.addEventListener('load', handler);
window.addEventListener('resize', handler);
window.addEventListener('scroll', handler);
document.addEventListener('DOMContentLoaded', handler);
```

---

## 5. Traversing the DOM

### Parent/Child Relationships

```javascript
const element = document.querySelector('.myElement');

// Parents
element.parentNode;           // Direct parent (any node)
element.parentElement;        // Direct parent (element only)
element.closest('.ancestor'); // Nearest ancestor matching selector

// Children
element.children;          // HTMLCollection of child elements
element.childNodes;        // NodeList of all child nodes (including text)
element.firstElementChild; // First child element
element.lastElementChild;  // Last child element
element.childElementCount; // Number of child elements

// Siblings
element.nextElementSibling;     // Next sibling element
element.previousElementSibling; // Previous sibling element
element.nextSibling;            // Next sibling node
element.previousSibling;        // Previous sibling node
```

### Practical Example: Tree Navigation

```html
<ul id="menu">
  <li>Item 1
    <ul>
      <li>Sub 1.1</li>
      <li>Sub 1.2</li>
    </ul>
  </li>
  <li>Item 2</li>
</ul>
```

```javascript
// Get all nested lists
function getAllLists(root) {
  const lists = [root];
  const children = root.querySelectorAll('ul');
  return [...lists, ...children];
}

// Toggle nested list visibility
document.getElementById('menu').addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    const nestedList = e.target.querySelector('ul');
    if (nestedList) {
      nestedList.classList.toggle('hidden');
    }
  }
});
```

---

## 6. Removing Elements

```javascript
const element = document.querySelector('.myElement');

// Modern way (preferred)
element.remove();

// Old way
element.parentNode.removeChild(element);

// Remove all children
element.innerHTML = '';
// or
while (element.firstChild) {
  element.removeChild(element.firstChild);
}
// or
element.replaceChildren(); // Modern, clears all children
```

---

## 7. Cloning Elements

```javascript
const original = document.querySelector('.original');

// Shallow clone (no children)
const shallowClone = original.cloneNode(false);

// Deep clone (with children)
const deepClone = original.cloneNode(true);

// Note: Event listeners are NOT cloned
// You need to re-attach them
```

---

## 8. Document Fragments (Performance)

```javascript
// Bad: Multiple reflows
const list = document.getElementById('list');
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  list.appendChild(li); // Triggers reflow each time
}

// Good: Single reflow
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);
}
list.appendChild(fragment); // Single reflow
```

---

## 9. Form Manipulation

```html
<form id="myForm">
  <input type="text" name="username" required>
  <input type="email" name="email" required>
  <input type="checkbox" name="subscribe" value="yes">
  <button type="submit">Submit</button>
</form>
```

```javascript
const form = document.getElementById('myForm');

// Get form data
form.addEventListener('submit', (e) => {
  e.preventDefault();
  
  // Method 1: FormData API
  const formData = new FormData(form);
  const data = Object.fromEntries(formData);
  console.log(data);
  
  // Method 2: Direct access
  const username = form.elements.username.value;
  const email = form.elements.email.value;
  const subscribe = form.elements.subscribe.checked;
  
  // Method 3: querySelector
  const username2 = form.querySelector('[name="username"]').value;
});

// Set form values
form.elements.username.value = 'John';
form.elements.email.value = 'john@example.com';
form.elements.subscribe.checked = true;

// Reset form
form.reset();

// Validate form
const isValid = form.checkValidity();
form.reportValidity(); // Shows validation messages
```

---

## 10. Practical Patterns

### Pattern 1: Debounced Search

```javascript
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

const searchInput = document.getElementById('search');
const resultsDiv = document.getElementById('results');

const performSearch = debounce((query) => {
  // Simulate API call
  resultsDiv.innerHTML = `Searching for: ${query}`;
}, 300);

searchInput.addEventListener('input', (e) => {
  performSearch(e.target.value);
});
```

### Pattern 2: Infinite Scroll

```javascript
const container = document.getElementById('container');
let page = 1;

function loadMore() {
  // Simulate loading data
  for (let i = 0; i < 10; i++) {
    const item = document.createElement('div');
    item.className = 'item';
    item.textContent = `Item ${(page - 1) * 10 + i + 1}`;
    container.appendChild(item);
  }
  page++;
}

// Intersection Observer for infinite scroll
const observer = new IntersectionObserver((entries) => {
  if (entries[0].isIntersecting) {
    loadMore();
  }
}, { threshold: 1.0 });

// Observe sentinel element
const sentinel = document.getElementById('sentinel');
observer.observe(sentinel);
```

### Pattern 3: Drag and Drop

```javascript
let draggedElement = null;

document.addEventListener('dragstart', (e) => {
  draggedElement = e.target;
  e.target.style.opacity = '0.5';
});

document.addEventListener('dragend', (e) => {
  e.target.style.opacity = '';
});

document.addEventListener('dragover', (e) => {
  e.preventDefault(); // Allow drop
});

document.addEventListener('drop', (e) => {
  e.preventDefault();
  if (e.target.classList.contains('dropzone')) {
    e.target.appendChild(draggedElement);
  }
});
```

---

## ðŸŽ¯ Key Concepts Summary

1. **Selection**: querySelector, querySelectorAll, getElementById
2. **Creation**: createElement, innerHTML, insertAdjacentHTML
3. **Modification**: classList, setAttribute, style, textContent
4. **Events**: addEventListener, event delegation, preventDefault
5. **Traversal**: parentElement, children, closest, siblings
6. **Performance**: DocumentFragment, event delegation, debouncing
7. **Forms**: FormData, validation, input events
8. **Modern APIs**: IntersectionObserver, MutationObserver

## ðŸ’¡ Interview Tips

- **Explain event delegation**: More efficient than multiple listeners
- **Know the difference**: innerHTML vs textContent vs innerText
- **Performance matters**: Use DocumentFragment for bulk operations
- **Security**: Be aware of XSS risks with innerHTML
- **Modern APIs**: IntersectionObserver, ResizeObserver, MutationObserver
